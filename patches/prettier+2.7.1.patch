diff --git a/node_modules/prettier/index.js b/node_modules/prettier/index.js
index e0a851e..625151e 100644
--- a/node_modules/prettier/index.js
+++ b/node_modules/prettier/index.js
@@ -26485,7 +26485,7 @@ var require_function = __commonJS2({
         parts.push("function ");
       }
       if (node.id) {
-        parts.push(print("id"));
+        parts.push(print("id"), " ");
       }
       const parametersDoc = printFunctionParameters(path, print, options, expandArg);
       const returnTypeDoc = printReturnType(path, print, options);
@@ -26529,7 +26529,7 @@ var require_function = __commonJS2({
       const parametersDoc = printFunctionParameters(path, print, options);
       const returnTypeDoc = printReturnType(path, print, options);
       const shouldGroupParameters = shouldGroupFunctionParameters(node, returnTypeDoc);
-      const parts = [printFunctionTypeParameters(path, options, print), group([shouldGroupParameters ? group(parametersDoc) : parametersDoc, returnTypeDoc])];
+      const parts = [printFunctionTypeParameters(path, options, print), " ", group([shouldGroupParameters ? group(parametersDoc) : parametersDoc, returnTypeDoc])];
       if (node.body) {
         parts.push(" ", print("body"));
       } else {
@@ -27803,7 +27803,7 @@ var require_ternary = __commonJS2({
       let jsxMode = false;
       const parent = path.getParentNode();
       const isParentTest = parent.type === node.type && testNodePropertyNames.some((prop) => parent[prop] === node);
-      let forceNoIndent = parent.type === node.type && !isParentTest;
+      let forceNoIndent = false
       let currentParent;
       let previousParent;
       let i = 0;
@@ -27821,7 +27821,8 @@ var require_ternary = __commonJS2({
         const isNil = (node2) => node2.type === "NullLiteral" || node2.type === "Literal" && node2.value === null || node2.type === "Identifier" && node2.name === "undefined";
         parts.push(" ? ", isNil(consequentNode) ? print(consequentNodePropertyName) : wrap(print(consequentNodePropertyName)), " : ", alternateNode.type === node.type || isNil(alternateNode) ? print(alternateNodePropertyName) : wrap(print(alternateNodePropertyName)));
       } else {
-        const part = [line, "? ", consequentNode.type === node.type ? ifBreak("", "(") : "", align(2, print(consequentNodePropertyName)), consequentNode.type === node.type ? ifBreak("", ")") : "", line, ": ", alternateNode.type === node.type ? print(alternateNodePropertyName) : align(2, print(alternateNodePropertyName))];
+        const alignAmount = consequentNode.type === 'ConditionalExpression' ? 0 : 2
+        const part = [line, "? ", consequentNode.type === node.type ? ifBreak("", "(") : "", align(alignAmount, print(consequentNodePropertyName)), consequentNode.type === node.type ? ifBreak("", ")") : "", line, ": ", alternateNode.type === node.type ? print(alternateNodePropertyName) : align(2, print(alternateNodePropertyName))];
         parts.push(parent.type !== node.type || parent[alternateNodePropertyName] === node || isParentTest ? part : options.useTabs ? dedent(indent(part)) : align(Math.max(0, options.tabWidth - 2), part));
       }
       const comments = [...testNodePropertyNames.map((propertyName) => getComments(node[propertyName])), getComments(consequentNode), getComments(alternateNode)].flat();
